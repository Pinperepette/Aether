import Foundation

// MARK: - Export Manager

/// Handles exporting analysis results to various formats
class ExportManager {

    // MARK: - Export Formats

    enum ExportFormat: String, CaseIterable {
        case idaPython = "IDA Python Script"
        case ghidraXML = "Ghidra XML"
        case radare2 = "Radare2 Script"
        case binaryNinja = "Binary Ninja Script"
        case json = "JSON"
        case csv = "CSV"
        case markdown = "Markdown Report"
        case html = "HTML Report"
        case cHeader = "C Header File"

        var fileExtension: String {
            switch self {
            case .idaPython: return "py"
            case .ghidraXML: return "xml"
            case .radare2: return "r2"
            case .binaryNinja: return "py"
            case .json: return "json"
            case .csv: return "csv"
            case .markdown: return "md"
            case .html: return "html"
            case .cHeader: return "h"
            }
        }
    }

    /// Export to file
    func export(binary: BinaryFile, functions: [Function], symbols: [Symbol], to url: URL, format: ExportFormat) throws {
        let content = export(binary: binary, functions: functions, strings: [], format: format)
        try content.write(to: url, atomically: true, encoding: .utf8)
    }

    // MARK: - Export

    /// Export analysis results to the specified format
    func export(
        binary: BinaryFile,
        functions: [Function],
        strings: [StringReference],
        format: ExportFormat
    ) -> String {
        switch format {
        case .idaPython:
            return exportToIDAPython(binary: binary, functions: functions, strings: strings)
        case .ghidraXML:
            return exportToGhidraXML(binary: binary, functions: functions, strings: strings)
        case .radare2:
            return exportToRadare2(binary: binary, functions: functions, strings: strings)
        case .binaryNinja:
            return exportToBinaryNinja(binary: binary, functions: functions, strings: strings)
        case .json:
            return exportToJSON(binary: binary, functions: functions, strings: strings)
        case .csv:
            return exportToCSV(functions: functions)
        case .markdown:
            return exportToMarkdown(binary: binary, functions: functions, strings: strings)
        case .html:
            return exportToHTML(binary: binary, functions: functions, strings: strings)
        case .cHeader:
            return exportToCHeader(binary: binary, functions: functions)
        }
    }

    // MARK: - IDA Python Export

    private func exportToIDAPython(binary: BinaryFile, functions: [Function], strings: [StringReference]) -> String {
        var script = """
        # IDA Python script generated by Aether Disassembler
        # Binary: \(binary.name)
        # Architecture: \(binary.architecture.rawValue)
        # Generated: \(Date())

        import idc
        import idaapi
        import idautils

        def apply_analysis():
            print("Applying Aether analysis...")

        """

        // Function names
        script += "\n    # Function names\n"
        for function in functions where !function.name.isEmpty {
            script += """
                idc.set_name(0x\(String(format: "%llX", function.startAddress)), "\(escapePythonString(function.name))", idc.SN_NOWARN)

            """
        }

        // Function comments
        script += "\n    # Function comments\n"
        for function in functions {
            if function.isLeaf {
                script += """
                    idc.set_func_cmt(0x\(String(format: "%llX", function.startAddress)), "Leaf function (no calls)", 0)

                """
            }
        }

        // String references
        script += "\n    # String cross-references\n"
        for str in strings.prefix(100) {  // Limit to prevent huge scripts
            let escaped = escapePythonString(str.value)
            script += """
                idc.set_cmt(0x\(String(format: "%llX", str.address)), "\(escaped)", 0)

            """
        }

        script += """

            print("Analysis applied successfully!")

        if __name__ == "__main__":
            apply_analysis()

        """

        return script
    }

    // MARK: - Ghidra XML Export

    private func exportToGhidraXML(binary: BinaryFile, functions: [Function], strings: [StringReference]) -> String {
        var xml = """
        <?xml version="1.0" encoding="UTF-8"?>
        <!-- Ghidra XML export generated by Aether Disassembler -->
        <!-- Binary: \(binary.name) -->
        <PROGRAM NAME="\(escapeXML(binary.name))" ARCHITECTURE="\(binary.architecture.rawValue)">
            <INFO_SOURCE>
                <TOOL>Aether Disassembler</TOOL>
                <DATE>\(ISO8601DateFormatter().string(from: Date()))</DATE>
            </INFO_SOURCE>

            <FUNCTIONS>

        """

        for function in functions {
            xml += """
                    <FUNCTION NAME="\(escapeXML(function.displayName))" ENTRY_POINT="0x\(String(format: "%llX", function.startAddress))">
                        <ADDRESS_RANGE START="0x\(String(format: "%llX", function.startAddress))" END="0x\(String(format: "%llX", function.endAddress))"/>
                        <STACK_FRAME SIZE="\(function.stackSize)"/>
                        <CALLING_CONVENTION>unknown</CALLING_CONVENTION>

            """

            // Parameters
            for (i, arg) in function.arguments.enumerated() {
                xml += """
                            <PARAMETER INDEX="\(i)" NAME="\(escapeXML(arg.name))" DATATYPE="\(escapeXML(arg.type))"/>

                """
            }

            // Local variables
            for local in function.localVariables {
                xml += """
                            <LOCAL_VAR NAME="\(escapeXML(local.name))" DATATYPE="\(escapeXML(local.type))" STACK_OFFSET="\(local.stackOffset)"/>

                """
            }

            xml += """
                    </FUNCTION>

            """
        }

        xml += """
            </FUNCTIONS>

            <SYMBOLS>

        """

        // Symbols
        for symbol in binary.symbols.prefix(500) {
            xml += """
                    <SYMBOL NAME="\(escapeXML(symbol.name))" ADDRESS="0x\(String(format: "%llX", symbol.address))" TYPE="\(symbol.type.rawValue)"/>

            """
        }

        xml += """
            </SYMBOLS>

            <STRINGS>

        """

        // Strings
        for str in strings.prefix(500) {
            xml += """
                    <STRING ADDRESS="0x\(String(format: "%llX", str.address))" VALUE="\(escapeXML(str.value))" ENCODING="\(str.encoding.rawValue)"/>

            """
        }

        xml += """
            </STRINGS>

        </PROGRAM>

        """

        return xml
    }

    // MARK: - Radare2 Export

    private func exportToRadare2(binary: BinaryFile, functions: [Function], strings: [StringReference]) -> String {
        var script = """
        # Radare2 script generated by Aether Disassembler
        # Binary: \(binary.name)
        # Usage: r2 -i script.r2 <binary>

        e asm.arch=\(r2Architecture(binary.architecture))
        e asm.bits=\(binary.architecture.is64Bit ? 64 : 32)


        """

        // Function definitions
        script += "# Function definitions\n"
        for function in functions {
            script += "af+ 0x\(String(format: "%llx", function.startAddress)) \(function.displayName)\n"
            script += "afb+ 0x\(String(format: "%llx", function.startAddress)) 0x\(String(format: "%llx", function.startAddress)) \(function.size)\n"
        }

        script += "\n# Comments\n"
        for function in functions where function.isLeaf {
            script += "CC Leaf function @ 0x\(String(format: "%llx", function.startAddress))\n"
        }

        script += "\n# String references\n"
        for str in strings.prefix(100) {
            let escaped = str.value.replacingOccurrences(of: "\"", with: "\\\"")
            script += "Cs \(str.value.count) @ 0x\(String(format: "%llx", str.address))\n"
        }

        return script
    }

    // MARK: - Binary Ninja Export

    private func exportToBinaryNinja(binary: BinaryFile, functions: [Function], strings: [StringReference]) -> String {
        var script = """
        # Binary Ninja Python script generated by Aether Disassembler
        # Binary: \(binary.name)

        from binaryninja import *

        def apply_analysis(bv):
            log_info("Applying Aether analysis...")


        """

        // Function names
        script += "    # Rename functions\n"
        for function in functions where !function.name.isEmpty {
            script += """
                func = bv.get_function_at(0x\(String(format: "%llx", function.startAddress)))
                if func:
                    func.name = "\(escapePythonString(function.name))"

            """
        }

        // Comments
        script += "\n    # Add comments\n"
        for function in functions where function.isLeaf {
            script += """
                bv.set_comment_at(0x\(String(format: "%llx", function.startAddress)), "Leaf function")

            """
        }

        script += """

            log_info("Analysis applied!")

        # Register as plugin
        PluginCommand.register(
            "Apply Aether Analysis",
            "Import analysis from Aether Disassembler",
            apply_analysis
        )

        """

        return script
    }

    // MARK: - JSON Export

    private func exportToJSON(binary: BinaryFile, functions: [Function], strings: [StringReference]) -> String {
        var result: [String: Any] = [:]

        result["binary"] = [
            "name": binary.name,
            "architecture": binary.architecture.rawValue,
            "format": binary.format.rawValue,
            "entryPoint": String(format: "0x%llX", binary.entryPoint),
            "exportDate": ISO8601DateFormatter().string(from: Date())
        ]

        result["functions"] = functions.map { fn -> [String: Any] in
            [
                "name": fn.displayName,
                "startAddress": String(format: "0x%llX", fn.startAddress),
                "endAddress": String(format: "0x%llX", fn.endAddress),
                "size": fn.size,
                "isLeaf": fn.isLeaf,
                "isThunk": fn.isThunk,
                "stackSize": fn.stackSize,
                "callers": fn.callers.map { String(format: "0x%llX", $0) },
                "callees": fn.callees.map { String(format: "0x%llX", $0) },
                "basicBlockCount": fn.basicBlocks.count
            ]
        }

        result["strings"] = strings.map { str -> [String: Any] in
            [
                "address": String(format: "0x%llX", str.address),
                "value": str.value,
                "encoding": str.encoding.rawValue,
                "xrefs": str.xrefs.map { String(format: "0x%llX", $0) }
            ]
        }

        result["symbols"] = binary.symbols.map { sym -> [String: Any] in
            [
                "name": sym.name,
                "address": String(format: "0x%llX", sym.address),
                "type": sym.type.rawValue,
                "binding": sym.binding.rawValue
            ]
        }

        // Convert to JSON string
        if let jsonData = try? JSONSerialization.data(withJSONObject: result, options: [.prettyPrinted, .sortedKeys]),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            return jsonString
        }

        return "{}"
    }

    // MARK: - CSV Export

    private func exportToCSV(functions: [Function]) -> String {
        var csv = "Name,Start Address,End Address,Size,Is Leaf,Is Thunk,Stack Size,Caller Count,Callee Count,Basic Blocks\n"

        for fn in functions {
            let row = [
                fn.displayName,
                String(format: "0x%llX", fn.startAddress),
                String(format: "0x%llX", fn.endAddress),
                String(fn.size),
                String(fn.isLeaf),
                String(fn.isThunk),
                String(fn.stackSize),
                String(fn.callers.count),
                String(fn.callees.count),
                String(fn.basicBlocks.count)
            ]
            csv += row.map { escapeCSV($0) }.joined(separator: ",") + "\n"
        }

        return csv
    }

    // MARK: - Markdown Export

    private func exportToMarkdown(binary: BinaryFile, functions: [Function], strings: [StringReference]) -> String {
        var md = """
        # Binary Analysis Report

        **Generated by Aether Disassembler**
        **Date:** \(Date())

        ## Binary Information

        | Property | Value |
        |----------|-------|
        | Name | \(binary.name) |
        | Architecture | \(binary.architecture.rawValue) |
        | Format | \(binary.format.rawValue) |
        | Entry Point | 0x\(String(format: "%llX", binary.entryPoint)) |
        | Sections | \(binary.sections.count) |
        | Symbols | \(binary.symbols.count) |

        ## Functions (\(functions.count) total)

        | Name | Address | Size | Type |
        |------|---------|------|------|

        """

        for fn in functions.prefix(100) {
            let fnType = fn.isThunk ? "Thunk" : (fn.isLeaf ? "Leaf" : "Normal")
            md += "| \(fn.displayName) | 0x\(String(format: "%llX", fn.startAddress)) | \(fn.size) | \(fnType) |\n"
        }

        if functions.count > 100 {
            md += "\n*... and \(functions.count - 100) more functions*\n"
        }

        md += "\n## Strings (\(strings.count) total)\n\n"
        md += "| Address | Value | Encoding |\n"
        md += "|---------|-------|----------|\n"

        for str in strings.prefix(50) {
            let escaped = str.value.prefix(50).replacingOccurrences(of: "|", with: "\\|")
            md += "| 0x\(String(format: "%llX", str.address)) | \(escaped) | \(str.encoding.rawValue) |\n"
        }

        if strings.count > 50 {
            md += "\n*... and \(strings.count - 50) more strings*\n"
        }

        md += """

        ## Statistics

        - Total functions: \(functions.count)
        - Leaf functions: \(functions.filter(\.isLeaf).count)
        - Thunk functions: \(functions.filter(\.isThunk).count)
        - Total strings: \(strings.count)
        - Average function size: \(functions.isEmpty ? 0 : functions.map { Int($0.size) }.reduce(0, +) / functions.count) bytes

        ---
        *Report generated by Aether Disassembler*

        """

        return md
    }

    // MARK: - HTML Export

    private func exportToHTML(binary: BinaryFile, functions: [Function], strings: [StringReference]) -> String {
        return """
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Binary Analysis - \(escapeXML(binary.name))</title>
            <style>
                body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 20px; background: #1a1a1a; color: #e0e0e0; }
                h1, h2 { color: #4fc3f7; }
                table { border-collapse: collapse; width: 100%; margin: 20px 0; }
                th, td { border: 1px solid #333; padding: 8px; text-align: left; }
                th { background: #2a2a2a; color: #4fc3f7; }
                tr:nth-child(even) { background: #222; }
                tr:hover { background: #333; }
                .address { font-family: monospace; color: #81c784; }
                .info-box { background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 10px 0; }
                .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
                .stat-card { background: #333; padding: 15px; border-radius: 8px; text-align: center; }
                .stat-value { font-size: 24px; font-weight: bold; color: #4fc3f7; }
            </style>
        </head>
        <body>
            <h1>Binary Analysis Report</h1>
            <p>Generated by Aether Disassembler - \(Date())</p>

            <div class="info-box">
                <h2>Binary Information</h2>
                <p><strong>Name:</strong> \(escapeXML(binary.name))</p>
                <p><strong>Architecture:</strong> \(binary.architecture.rawValue)</p>
                <p><strong>Format:</strong> \(binary.format.rawValue)</p>
                <p><strong>Entry Point:</strong> <span class="address">0x\(String(format: "%llX", binary.entryPoint))</span></p>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value">\(functions.count)</div>
                    <div>Functions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">\(strings.count)</div>
                    <div>Strings</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">\(binary.symbols.count)</div>
                    <div>Symbols</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">\(binary.sections.count)</div>
                    <div>Sections</div>
                </div>
            </div>

            <h2>Functions</h2>
            <table>
                <tr><th>Name</th><th>Address</th><th>Size</th><th>Type</th><th>Calls</th></tr>
                \(functions.prefix(200).map { fn in
                    let fnType = fn.isThunk ? "Thunk" : (fn.isLeaf ? "Leaf" : "Normal")
                    return "<tr><td>\(escapeXML(fn.displayName))</td><td class=\"address\">0x\(String(format: "%llX", fn.startAddress))</td><td>\(fn.size)</td><td>\(fnType)</td><td>\(fn.callees.count)</td></tr>"
                }.joined(separator: "\n"))
            </table>

            <h2>Strings</h2>
            <table>
                <tr><th>Address</th><th>Value</th><th>Encoding</th></tr>
                \(strings.prefix(100).map { str in
                    "<tr><td class=\"address\">0x\(String(format: "%llX", str.address))</td><td>\(escapeXML(String(str.value.prefix(80))))</td><td>\(str.encoding.rawValue)</td></tr>"
                }.joined(separator: "\n"))
            </table>

            <footer style="margin-top: 40px; text-align: center; color: #666;">
                Generated by Aether Disassembler
            </footer>
        </body>
        </html>
        """
    }

    // MARK: - C Header Export

    private func exportToCHeader(binary: BinaryFile, functions: [Function]) -> String {
        var header = """
        /*
         * C Header generated by Aether Disassembler
         * Binary: \(binary.name)
         * Architecture: \(binary.architecture.rawValue)
         * Generated: \(Date())
         */

        #ifndef _\(binary.name.uppercased().replacingOccurrences(of: ".", with: "_"))_H
        #define _\(binary.name.uppercased().replacingOccurrences(of: ".", with: "_"))_H

        #include <stdint.h>

        /* Function addresses */

        """

        for function in functions where !function.name.isEmpty {
            let safeName = function.displayName
                .replacingOccurrences(of: " ", with: "_")
                .replacingOccurrences(of: "-", with: "_")
            header += "#define ADDR_\(safeName.uppercased()) 0x\(String(format: "%llX", function.startAddress))ULL\n"
        }

        header += "\n/* Function declarations */\n\n"

        for function in functions where !function.name.isEmpty {
            // Generate function prototype
            let returnType = function.isLeaf ? "void" : "int"
            var params = "void"
            if !function.arguments.isEmpty {
                params = function.arguments.map { "\($0.type) \($0.name)" }.joined(separator: ", ")
            }

            header += "\(returnType) \(function.displayName)(\(params));\n"
        }

        header += "\n#endif /* _\(binary.name.uppercased().replacingOccurrences(of: ".", with: "_"))_H */\n"

        return header
    }

    // MARK: - Helpers

    private func escapePythonString(_ str: String) -> String {
        str.replacingOccurrences(of: "\\", with: "\\\\")
           .replacingOccurrences(of: "\"", with: "\\\"")
           .replacingOccurrences(of: "\n", with: "\\n")
           .replacingOccurrences(of: "\r", with: "\\r")
    }

    private func escapeXML(_ str: String) -> String {
        str.replacingOccurrences(of: "&", with: "&amp;")
           .replacingOccurrences(of: "<", with: "&lt;")
           .replacingOccurrences(of: ">", with: "&gt;")
           .replacingOccurrences(of: "\"", with: "&quot;")
           .replacingOccurrences(of: "'", with: "&apos;")
    }

    private func escapeCSV(_ str: String) -> String {
        if str.contains(",") || str.contains("\"") || str.contains("\n") {
            return "\"\(str.replacingOccurrences(of: "\"", with: "\"\""))\""
        }
        return str
    }

    private func r2Architecture(_ arch: Architecture) -> String {
        switch arch {
        case .x86_64: return "x86"
        case .i386: return "x86"
        case .arm64, .arm64e: return "arm"
        case .armv7: return "arm"
        case .jvm: return "java"
        case .unknown: return "x86"
        }
    }
}

// MARK: - Binary Diff

/// Compares two binaries and generates a diff report
class ExportBinaryDiffer {

    struct DiffResult {
        let addedFunctions: [Function]
        let removedFunctions: [Function]
        let modifiedFunctions: [(old: Function, new: Function, changes: [FunctionChange])]
        let addedStrings: [StringReference]
        let removedStrings: [StringReference]
    }

    enum FunctionChange {
        case sizeChanged(oldSize: UInt64, newSize: UInt64)
        case instructionsChanged(count: Int)
        case callsChanged(added: [UInt64], removed: [UInt64])
        case nameChanged(oldName: String, newName: String)
    }

    /// Compare two binaries
    func diff(
        oldBinary: BinaryFile, oldFunctions: [Function], oldStrings: [StringReference],
        newBinary: BinaryFile, newFunctions: [Function], newStrings: [StringReference]
    ) -> DiffResult {

        // Index functions by name for matching
        let oldByName = Dictionary(uniqueKeysWithValues: oldFunctions.map { ($0.displayName, $0) })
        let newByName = Dictionary(uniqueKeysWithValues: newFunctions.map { ($0.displayName, $0) })

        // Find added functions
        let addedFunctions = newFunctions.filter { oldByName[$0.displayName] == nil }

        // Find removed functions
        let removedFunctions = oldFunctions.filter { newByName[$0.displayName] == nil }

        // Find modified functions
        var modifiedFunctions: [(Function, Function, [FunctionChange])] = []

        for newFn in newFunctions {
            if let oldFn = oldByName[newFn.displayName] {
                let changes = compareFunctions(old: oldFn, new: newFn)
                if !changes.isEmpty {
                    modifiedFunctions.append((oldFn, newFn, changes))
                }
            }
        }

        // Compare strings
        let oldStringValues = Set(oldStrings.map(\.value))
        let newStringValues = Set(newStrings.map(\.value))

        let addedStrings = newStrings.filter { !oldStringValues.contains($0.value) }
        let removedStrings = oldStrings.filter { !newStringValues.contains($0.value) }

        return DiffResult(
            addedFunctions: addedFunctions,
            removedFunctions: removedFunctions,
            modifiedFunctions: modifiedFunctions,
            addedStrings: addedStrings,
            removedStrings: removedStrings
        )
    }

    private func compareFunctions(old: Function, new: Function) -> [FunctionChange] {
        var changes: [FunctionChange] = []

        // Size change
        if old.size != new.size {
            changes.append(.sizeChanged(oldSize: old.size, newSize: new.size))
        }

        // Instruction count change
        let oldInsnCount = old.basicBlocks.flatMap(\.instructions).count
        let newInsnCount = new.basicBlocks.flatMap(\.instructions).count
        if oldInsnCount != newInsnCount {
            changes.append(.instructionsChanged(count: newInsnCount - oldInsnCount))
        }

        // Call changes
        let addedCalls = new.callees.subtracting(old.callees)
        let removedCalls = old.callees.subtracting(new.callees)
        if !addedCalls.isEmpty || !removedCalls.isEmpty {
            changes.append(.callsChanged(added: Array(addedCalls), removed: Array(removedCalls)))
        }

        return changes
    }

    /// Generate diff report as Markdown
    func generateReport(_ diff: DiffResult) -> String {
        var report = """
        # Binary Diff Report

        **Generated:** \(Date())

        ## Summary

        - Added functions: \(diff.addedFunctions.count)
        - Removed functions: \(diff.removedFunctions.count)
        - Modified functions: \(diff.modifiedFunctions.count)
        - Added strings: \(diff.addedStrings.count)
        - Removed strings: \(diff.removedStrings.count)

        """

        if !diff.addedFunctions.isEmpty {
            report += "\n## Added Functions\n\n"
            for fn in diff.addedFunctions {
                report += "- **\(fn.displayName)** at 0x\(String(format: "%llX", fn.startAddress)) (\(fn.size) bytes)\n"
            }
        }

        if !diff.removedFunctions.isEmpty {
            report += "\n## Removed Functions\n\n"
            for fn in diff.removedFunctions {
                report += "- **\(fn.displayName)** at 0x\(String(format: "%llX", fn.startAddress)) (\(fn.size) bytes)\n"
            }
        }

        if !diff.modifiedFunctions.isEmpty {
            report += "\n## Modified Functions\n\n"
            for (old, new, changes) in diff.modifiedFunctions {
                report += "### \(new.displayName)\n\n"
                for change in changes {
                    switch change {
                    case .sizeChanged(let oldSize, let newSize):
                        report += "- Size: \(oldSize) → \(newSize) bytes\n"
                    case .instructionsChanged(let count):
                        report += "- Instructions: \(count > 0 ? "+" : "")\(count)\n"
                    case .callsChanged(let added, let removed):
                        if !added.isEmpty {
                            report += "- New calls: \(added.map { String(format: "0x%llX", $0) }.joined(separator: ", "))\n"
                        }
                        if !removed.isEmpty {
                            report += "- Removed calls: \(removed.map { String(format: "0x%llX", $0) }.joined(separator: ", "))\n"
                        }
                    case .nameChanged(let oldName, let newName):
                        report += "- Renamed: \(oldName) → \(newName)\n"
                    }
                }
                report += "\n"
            }
        }

        return report
    }
}
